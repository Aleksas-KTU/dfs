// @ts-nocheck
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: rpc_common.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace rpc_common {
  export class Empty extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): Empty {
      const message = new Empty({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Empty();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Empty {
      return Empty.deserialize(bytes);
    }
  }
  export class Guid extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            guid?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("guid" in data && data.guid != undefined) {
          this.guid = data.guid;
        }
      }
    }
    get guid() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set guid(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { guid?: string }): Guid {
      const message = new Guid({});
      if (data.guid != null) {
        message.guid = data.guid;
      }
      return message;
    }
    toObject() {
      const data: {
        guid?: string;
      } = {};
      if (this.guid != null) {
        data.guid = this.guid;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.guid.length) writer.writeString(1, this.guid);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Guid {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Guid();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.guid = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Guid {
      return Guid.deserialize(bytes);
    }
  }
  export class GuidList extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            guid?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("guid" in data && data.guid != undefined) {
          this.guid = data.guid;
        }
      }
    }
    get guid() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set guid(value: string[]) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { guid?: string[] }): GuidList {
      const message = new GuidList({});
      if (data.guid != null) {
        message.guid = data.guid;
      }
      return message;
    }
    toObject() {
      const data: {
        guid?: string[];
      } = {};
      if (this.guid != null) {
        data.guid = this.guid;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.guid.length) writer.writeRepeatedString(1, this.guid);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GuidList {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new GuidList();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            pb_1.Message.addToRepeatedField(message, 1, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GuidList {
      return GuidList.deserialize(bytes);
    }
  }
  export class Hash extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: Uint8Array;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("data" in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        new Uint8Array(0),
      ) as Uint8Array;
    }
    set data(value: Uint8Array) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: Uint8Array }): Hash {
      const message = new Hash({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: Uint8Array;
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writeBytes(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Hash {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Hash();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readBytes();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Hash {
      return Hash.deserialize(bytes);
    }
  }
}
