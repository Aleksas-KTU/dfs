// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "rpc/tracker.proto" (package "tracker", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Tracker } from "./tracker";
import type { UsageReport } from "./tracker";
import type { DataUsage } from "../rpc_common";
import type { SearchResponse } from "../rpc_common";
import type { SearchRequest } from "./tracker";
import type { TransactionStateResponse } from "./tracker";
import type { TransactionStartResponse } from "./tracker";
import type { PublishedObject } from "./tracker";
import type { ContainerRootHash } from "./tracker";
import type { Guid } from "../rpc_common";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { PeerResponse } from "./tracker";
import type { PeerRequest } from "./tracker";
import type { Empty } from "../rpc_common";
import type { MarkRequest } from "./tracker";
import type { ClientStreamingCall } from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ObjectWithHash } from "../fs/filesystem";
import type { Hash } from "../rpc_common";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service tracker.Tracker
 */
export interface ITrackerClient {
  /**
   * @generated from protobuf rpc: GetObjectTree(rpc_common.Hash) returns (stream fs.ObjectWithHash);
   */
  getObjectTree(
    input: Hash,
    options?: RpcOptions,
  ): ServerStreamingCall<Hash, ObjectWithHash>;
  /**
   * @generated from protobuf rpc: MarkReachable(stream tracker.MarkRequest) returns (rpc_common.Empty);
   */
  markReachable(options?: RpcOptions): ClientStreamingCall<MarkRequest, Empty>;
  /**
   * @generated from protobuf rpc: MarkUnreachable(stream tracker.MarkRequest) returns (rpc_common.Empty);
   */
  markUnreachable(
    options?: RpcOptions,
  ): ClientStreamingCall<MarkRequest, Empty>;
  /**
   * @generated from protobuf rpc: GetPeerList(tracker.PeerRequest) returns (stream tracker.PeerResponse);
   */
  getPeerList(
    input: PeerRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<PeerRequest, PeerResponse>;
  /**
   * @generated from protobuf rpc: GetContainerRootHash(rpc_common.Guid) returns (rpc_common.Hash);
   */
  getContainerRootHash(
    input: Guid,
    options?: RpcOptions,
  ): UnaryCall<Guid, Hash>;
  /**
   * container transactions
   *
   * @generated from protobuf rpc: SetContainerRootHash(tracker.ContainerRootHash) returns (rpc_common.Empty);
   */
  setContainerRootHash(
    input: ContainerRootHash,
    options?: RpcOptions,
  ): UnaryCall<ContainerRootHash, Empty>;
  /**
   * @generated from protobuf rpc: Publish(stream tracker.PublishedObject) returns (rpc_common.Empty);
   */
  publish(options?: RpcOptions): ClientStreamingCall<PublishedObject, Empty>;
  /**
   * @generated from protobuf rpc: StartTransaction(rpc_common.Empty) returns (tracker.TransactionStartResponse);
   */
  startTransaction(
    input: Empty,
    options?: RpcOptions,
  ): UnaryCall<Empty, TransactionStartResponse>;
  /**
   * @generated from protobuf rpc: CheckTransactionState(rpc_common.Guid) returns (tracker.TransactionStateResponse);
   */
  checkTransactionState(
    input: Guid,
    options?: RpcOptions,
  ): UnaryCall<Guid, TransactionStateResponse>;
  /**
   * @generated from protobuf rpc: SearchForObjects(tracker.SearchRequest) returns (stream rpc_common.SearchResponse);
   */
  searchForObjects(
    input: SearchRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SearchRequest, SearchResponse>;
  /**
   * @generated from protobuf rpc: GetDataUsage(rpc_common.Empty) returns (rpc_common.DataUsage);
   */
  getDataUsage(input: Empty, options?: RpcOptions): UnaryCall<Empty, DataUsage>;
  /**
   * @generated from protobuf rpc: ReportDataUsage(tracker.UsageReport) returns (rpc_common.Empty);
   */
  reportDataUsage(
    input: UsageReport,
    options?: RpcOptions,
  ): UnaryCall<UsageReport, Empty>;
}
/**
 * @generated from protobuf service tracker.Tracker
 */
export class TrackerClient implements ITrackerClient, ServiceInfo {
  typeName = Tracker.typeName;
  methods = Tracker.methods;
  options = Tracker.options;
  constructor(private readonly _transport: RpcTransport) {}
  /**
   * @generated from protobuf rpc: GetObjectTree(rpc_common.Hash) returns (stream fs.ObjectWithHash);
   */
  getObjectTree(
    input: Hash,
    options?: RpcOptions,
  ): ServerStreamingCall<Hash, ObjectWithHash> {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Hash, ObjectWithHash>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: MarkReachable(stream tracker.MarkRequest) returns (rpc_common.Empty);
   */
  markReachable(options?: RpcOptions): ClientStreamingCall<MarkRequest, Empty> {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<MarkRequest, Empty>(
      "clientStreaming",
      this._transport,
      method,
      opt,
    );
  }
  /**
   * @generated from protobuf rpc: MarkUnreachable(stream tracker.MarkRequest) returns (rpc_common.Empty);
   */
  markUnreachable(
    options?: RpcOptions,
  ): ClientStreamingCall<MarkRequest, Empty> {
    const method = this.methods[2],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<MarkRequest, Empty>(
      "clientStreaming",
      this._transport,
      method,
      opt,
    );
  }
  /**
   * @generated from protobuf rpc: GetPeerList(tracker.PeerRequest) returns (stream tracker.PeerResponse);
   */
  getPeerList(
    input: PeerRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<PeerRequest, PeerResponse> {
    const method = this.methods[3],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<PeerRequest, PeerResponse>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: GetContainerRootHash(rpc_common.Guid) returns (rpc_common.Hash);
   */
  getContainerRootHash(
    input: Guid,
    options?: RpcOptions,
  ): UnaryCall<Guid, Hash> {
    const method = this.methods[4],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Guid, Hash>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * container transactions
   *
   * @generated from protobuf rpc: SetContainerRootHash(tracker.ContainerRootHash) returns (rpc_common.Empty);
   */
  setContainerRootHash(
    input: ContainerRootHash,
    options?: RpcOptions,
  ): UnaryCall<ContainerRootHash, Empty> {
    const method = this.methods[5],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<ContainerRootHash, Empty>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: Publish(stream tracker.PublishedObject) returns (rpc_common.Empty);
   */
  publish(options?: RpcOptions): ClientStreamingCall<PublishedObject, Empty> {
    const method = this.methods[6],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<PublishedObject, Empty>(
      "clientStreaming",
      this._transport,
      method,
      opt,
    );
  }
  /**
   * @generated from protobuf rpc: StartTransaction(rpc_common.Empty) returns (tracker.TransactionStartResponse);
   */
  startTransaction(
    input: Empty,
    options?: RpcOptions,
  ): UnaryCall<Empty, TransactionStartResponse> {
    const method = this.methods[7],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Empty, TransactionStartResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: CheckTransactionState(rpc_common.Guid) returns (tracker.TransactionStateResponse);
   */
  checkTransactionState(
    input: Guid,
    options?: RpcOptions,
  ): UnaryCall<Guid, TransactionStateResponse> {
    const method = this.methods[8],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Guid, TransactionStateResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: SearchForObjects(tracker.SearchRequest) returns (stream rpc_common.SearchResponse);
   */
  searchForObjects(
    input: SearchRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SearchRequest, SearchResponse> {
    const method = this.methods[9],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<SearchRequest, SearchResponse>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: GetDataUsage(rpc_common.Empty) returns (rpc_common.DataUsage);
   */
  getDataUsage(
    input: Empty,
    options?: RpcOptions,
  ): UnaryCall<Empty, DataUsage> {
    const method = this.methods[10],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Empty, DataUsage>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * @generated from protobuf rpc: ReportDataUsage(tracker.UsageReport) returns (rpc_common.Empty);
   */
  reportDataUsage(
    input: UsageReport,
    options?: RpcOptions,
  ): UnaryCall<UsageReport, Empty> {
    const method = this.methods[11],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<UsageReport, Empty>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
}
